(defun add (x y)
  (+ x y))

(defun sub (x y)
  (- x y))

(defun mul (x y)
  (* x y))

(defun div (x y)
  (/ x y))

(defun compute (op x y)
  (if (equal op 'add-op)
      (add x y)
      (if (equal op 'sub-op)
	  (sub x y)
	  (if (equal op 'mul-op)
	      (mul x y)
	      (if (equal op 'div-op)
		  (div x y)
		  -1)))))

(setq codecompute '((label add-op)
		    (:const 0)
		    (label sub-op)
		    (:const 1)
		    (label mul-op)
		    (:const 2)
		    (label div-op)
		    (:const 3)
		    (label compute)
		    (load (:ref add-op) R0)
		    (cmp R0 (fp -3))
		    (jeq label compute-0-ok)
		    (load (:ref sub-op) R0)
		    (cmp R0 (fp -3))
		    (jeq label compute-0-1-ok)
		    (move (:const -1) R0)
		    (jmp compute-0-exit)
		    (label compute-0-ok)
		    (push (fp -2))
		    (push (fp -1))
		    (move sp fp)
		    (push (:const 2))
		    (jsr add)
		    (add (:const -2) fp)
		    (add (:const -2) sp)
		    (jmp compute-0-exit)
		    (label compute-0-1-ok)
		    (push (fp -2))
		    (push (fp -1))
		    (move sp fp)
		    (push (:const 2))
		    (jsr sub)
		    (add (:const -2) fp)
		    (add (:const -2) sp)
		    (jmp compute-0-exit)
		    (label compute-0-exit)
		    (rtn)
		    (label add)
		    (move (fp -2) R1)
		    (move (fp -1) R0)
		    (add R1 R0)
		    (rtn)
		    (label sub)
		    (move (fp -2) R1)
		    (move (fp -1) R0)
		    (sub R1 R0)
		    (rtn)
		    (label mul)
		    (move (fp -2) R1)
		    (move (fp -1) R0)
		    (mul R1 R0)
		    (rtn)
		    (label div)
		    (move (fp -2) R1)
		    (move (fp -1) R0)
		    (div R1 R0)
		    (rtn)))
