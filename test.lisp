;; (require 'codecompute "./res/compute.lisp")
;; (require 'fact "./res/fact.lisp")
(require 'fact "./res/fibo.lisp")
(require 'init "./init.lisp")

(defun test-compile-run (basecode)
  (let ((code (compile-code basecode)))
    (print "Code : ")
    (print code)
    (test-run code)))

(defun test-run (code)
  (let ((vm (make-vm :name "vm" :memory-size 100 :stack-size 50)))
    (vm-load code :vm vm)
    (let ((result (vm-run :main nil :vm vm)))
      (print "Result : ")
      (print result))))


(compile-cl-to-li1 (factsource 10))
((:FUNCTION FACT (:ARGS N)
  (:BODY
   (:IF (:EQ (:ARG N) (:CONST 1)) :THEN (:CONST 1) :ELSE
    (:MUL (:ARG N) (:CALL FACT (:SUB (:ARG N) (:CONST 1)))))))
 (:CALL FACT (:CONST 10)))

(compile-code (factsource 10))
;; ((JSR MAIN)
;;  (HALT)
;;  (LABEL FACT)
;;  (MOVE (FP -1) R0)
;;  (MOVE R0 R1)
;;  (MOVE (:CONST 1) R0) (CMP R1 R0)
;;  (JEQ 0)
;;  (MOVE (FP -1) R0)
;;  (MOVE R0 R1)
;;  (MOVE (FP -1) R0)
;;  (MOVE R0 R1)
;;  (MOVE (:CONST 1) R0)
;;  (SUB R1 R0)
;;  (PUSH R0)
;;  (MOVE FP R1)
;;  (MOVE SP FP)
;;  (PUSH (:CONST 1))
;;  (PUSH R1)
;;  (JSR FACT)
;;  (POP FP)
;;  (ADD (:CONST -2) SP)
;;  (MUL R1 R0) (JMP 1)
;;  (LABEL 0)
;;  (MOVE (:CONST 1) R0)
;;  (LABEL 1)
;;  (RTN)
;;  (LABEL MAIN)
;;  (MOVE (:CONST 10) R0)
;;  (PUSH R0)
;;  (MOVE FP R1)
;;  (MOVE SP FP)
;;  (PUSH (:CONST 1))
;;  (PUSH R1)
;;  (JSR FACT)
;;  (POP FP)
;;  (ADD (:CONST -2) SP)
;;  (RTN))

;; (test-compile-run '((defun add(x y) (+ x y)) (add 5 3)))
;; (test-run (factvm 10))
;; (test-run codefibo)
;; (test-compile-run (compute-code 'add-op 1 2))
